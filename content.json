{"meta":{"title":"Zihan's Blog","subtitle":"","description":"Keep a log of development and learning activities.","author":"Zihan Liu","url":"https://loveaiblog.github.io","root":"/"},"pages":[{"title":"categories","date":"2025-03-01T17:15:21.000Z","updated":"2025-03-01T17:15:21.285Z","comments":true,"path":"categories/index.html","permalink":"https://loveaiblog.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Convert Mask from Numpy Array to RLE (Run-Length Encoding) for CVAT","slug":"mask2rle","date":"2025-03-04T13:27:00.000Z","updated":"2025-03-04T13:27:52.860Z","comments":true,"path":"2025/03/04/mask2rle/","permalink":"https://loveaiblog.github.io/2025/03/04/mask2rle/","excerpt":"","text":"Convert Mask from Numpy Array to RLE (Run-Length Encoding) for CVATWhat is RLE?When reading a mask in the format of numpy.array line by line, you often encounter long sequences of consecutive 0 (or False) followed by sequences of 1 (or True). Based on this observation, we can first define a bounding box that encloses the mask. Then, we read the values line by line within this box and record the counts of consecutive values. For example, consider the following mask enclosed in a box: 12[[0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]] Reading this mask line by line, we get the sequence: 3*0, 6*1, 5*0, 7*1, 3*0. This sequence can be efficiently encoded as the RLE string: &#39;3,6,5,7,3&#39;. If the mask starts with a 1 instead of a 0, we prepend a 0 to the RLE string to indicate that there are zero 0s at the beginning. This is the standard rule for converting a mask to RLE format. Standard Implementation12345678910111213141516171819202122232425def binary_image_mask_to_cvat_rle(mask: np.ndarray) -&gt; dict: # Get box information yy, xx = np.nonzero(mask) top, left = np.min(yy), np.min(xx) bottom, right = np.max(yy), np.max(xx) height, width = bottom - top + 1, right - left + 1 rle = [] offset = 0 # How many consecutive &#x27;0&#x27;s or &#x27;1&#x27;s value = 0 # Are we counting &#x27;0&#x27; or &#x27;1&#x27; # Read line by line for y in range(top, top + height): for x in range(left, left + width): if mask[y][x] == value: offset += 1 else: rle.append(offset) # Save to RLE offset = 1 # Reset &#x27;offset&#x27; value = 1 - value # Flip &#x27;value&#x27; if offset &gt; 0: rle.append(offset) return &#123;&quot;rle&quot;: rle, &quot;left&quot;: left, &quot;top&quot;: top, &quot;width&quot;: width, &quot;height&quot;: height&#125; The code requires iterating over the entire box, resulting in a loop that runs height * width times. Converting a single mask to RLE takes about 0.02 seconds on my device. When processing masks in batches, you might need to wait for tens of seconds in the CVAT interface just for format conversion. We can replace the above method with a parallelizable approach. Time-efficient ImplementationFirst, we need to determine which positions in the mask transition from 0 to 1 and which positions transition from 1 to 0. 123456bbox_mask = mask[top:bottom + 1, left:right + 1]flat_mask = bbox_mask.flatten() # transform the mask to a 1D arraydiff = np.diff(flat_mask, prepend=0) # compute the differencesstarts = np.where(diff == 1)[0] # find where the value changes from 0 to 1ends = np.where(diff == -1)[0] # find where the value changes from 1 to 0 Since the first number in RLE must represent the count of 0s, we will discuss two scenarios based on the initial value of the mask. When the mask starts with 1 Due to the use of prepend=0, when the first element of the mask is 1, starts[0] will be 0. In this case: 12345678rle.append(0)for i in range(len(starts) - 1): rle.append(ends[i] - starts[i]) rle.append(starts[i + 1] - ends[i])if starts.shape[0] &lt; ends.shape[0]: rle.append(len(flat_mask) - ends[-1])else: rle.append(len(flat_mask) - starts[-1]) The handling depends on the value of the last element. If the last element is also 1, then starts will have one more element than ends, and RLE appends len(flat_mask) - starts[-1]. If the last element is 0, then starts and ends will have the same number of elements, and RLE should append len(flat_mask) - ends[-1]. When the mask starts with 0 1234567891011rle.append(starts[0])for i in range(len(ends) - 1): rle.append(ends[i] - starts[i]) rle.append(starts[i + 1] - ends[i])if starts.shape[0] &gt; ends.shape[0]: rle.append(ends[-1] - starts[-2]) rle.append(starts[-1] - ends[-1]) rle.append(len(flat_mask) - starts[-1])else: rle.append(ends[-1] - starts[-1]) rle.append(len(flat_mask) - ends[-1]) It is important to note that RLE starts with starts[0] rather than starts[0] - ends[0]. This is because prepend=0 causes ends[0] != 0. Similarly, depending on the value of the last element, the handling of the end is divided into two cases, which will not be elaborated here. The time-efficient implementation: 123456789101112131415161718192021222324252627282930313233343536373839def binary_image_mask_to_cvat_rle(mask: np.ndarray) -&gt; dict: yy, xx = np.nonzero(mask) top, left = np.min(yy), np.min(xx) bottom, right = np.max(yy), np.max(xx) height, width = bottom - top + 1, right - left + 1 bbox_mask = mask[top:bottom + 1, left:right + 1] flat_mask = bbox_mask.flatten() diff = np.diff(flat_mask, prepend=0) starts = np.where(diff == 1)[0] ends = np.where(diff == -1)[0] rle = [] if starts[0]==0: rle.append(0) for i in range(len(starts)-1): rle.append(ends[i] - starts[i]) rle.append(starts[i+1] - ends[i]) if starts.shape[0] &lt; ends.shape[0]: rle.append(len(flat_mask)-ends[-1]) else: rle.append(len(flat_mask)-starts[-1]) else: rle.append(starts[0]) for i in range(len(ends) - 1): rle.append(ends[i] - starts[i]) rle.append(starts[i+1] - ends[i]) if starts.shape[0] &gt; ends.shape[0]: rle.append(ends[-1] - starts[-2]) rle.append(starts[-1] - ends[-1]) rle.append(len(flat_mask) - starts[-1]) else: rle.append(ends[-1] - starts[-1]) rle.append(len(flat_mask) - ends[-1]) return &#123;&quot;rle&quot;: rle, &quot;left&quot;: left, &quot;top&quot;: top, &quot;width&quot;: width, &quot;height&quot;: height&#125;","categories":[],"tags":[{"name":"Development","slug":"Development","permalink":"https://loveaiblog.github.io/tags/Development/"}]}],"categories":[],"tags":[{"name":"Development","slug":"Development","permalink":"https://loveaiblog.github.io/tags/Development/"}]}